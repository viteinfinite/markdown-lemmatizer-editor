<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Éditeur Markdown avec lemmatisation</title>
  <!--
    Nous chargeons les feuilles de style et les scripts de CodeMirror 5 depuis
    la CDN.  CodeMirror 5 est plus simple à utiliser directement dans un
    navigateur sans bundler et convient parfaitement à un éditeur Markdown.
  -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css"
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/eclipse.min.css"
  />
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, Helvetica, Arial, sans-serif;
      /* Utiliser une colonne flex pour placer le titre au-dessus de l'éditeur. */
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    .editor-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    h1 {
      margin: 1rem;
      font-size: 1.4rem;
      text-align: center;
    }
    .controls {
      padding: 0 1rem 1rem;
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
      border-bottom: 1px solid #ddd;
      background: #f8f9fa;
    }
    .analysis-button {
      padding: 0.5rem 1rem;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .analysis-button:hover {
      background: #0056b3;
    }
    .analysis-button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    .progress-container {
      flex: 1;
      min-width: 200px;
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background: #28a745;
      width: 0%;
      transition: width 0.3s ease;
    }
    .status-text {
      font-size: 0.8rem;
      color: #6c757d;
      margin-top: 0.25rem;
    }
    .stats {
      font-size: 0.8rem;
      color: #495057;
      white-space: nowrap;
    }
    .error-message {
      color: #dc3545;
      font-size: 0.8rem;
      margin-top: 0.25rem;
    }
    #editor {
      /* Allouer tout l'espace restant à l'éditeur. */
      flex: 1;
      width: 100%;
      /* Définir une hauteur minimale pour s'assurer qu'il apparaît. */
      min-height: 200px;
    }
    /*
      Classes de heatmap pour surligner les mots répétés avec différents
      niveaux d'intensité. Plus le niveau est élevé, plus le mot est répété.
      Les couleurs vont du jaune clair (peu répété) au rouge foncé (très répété).
      Opacité augmentée pour meilleure visibilité.
    */
    .CodeMirror .heat-1 {
      background: rgba(255, 255, 0, 0.4); /* Jaune très clair - plus visible */
      border-radius: 2px;
    }
    .CodeMirror .heat-2 {
      background: rgba(255, 200, 0, 0.5); /* Jaune-orange - plus visible */
      border-radius: 2px;
    }
    .CodeMirror .heat-3 {
      background: rgba(255, 165, 0, 0.6); /* Orange - plus visible */
      border-radius: 2px;
    }
    .CodeMirror .heat-4 {
      background: rgba(255, 100, 0, 0.7); /* Orange-rouge - plus visible */
      border-radius: 2px;
    }
    .CodeMirror .heat-5 {
      background: rgba(255, 50, 0, 0.8); /* Rouge - très visible */
      border-radius: 2px;
    }
    /* Pour les niveaux supérieurs à 5, utiliser le niveau 5 */
    .CodeMirror [class^="heat-"] {
      border-radius: 2px;
    }
    
    /* Sidebar pour afficher les lemmes répétés */
    .sidebar {
      width: 300px;
      background: #f8f9fa;
      border-left: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: width 0.3s ease, border 0.3s ease;
    }
    .sidebar.hidden {
      width: 0;
      border-left: none;
      overflow: hidden;
    }
    .sidebar-header {
      padding: 1rem;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: white;
    }
    .sidebar-header h2 {
      margin: 0;
      font-size: 1.1rem;
      color: #495057;
    }
    .sidebar-toggle {
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      color: #6c757d;
      padding: 0.25rem 0.5rem;
    }
    .sidebar-toggle:hover {
      color: #495057;
    }
    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
      min-width: 0;
    }
    .sidebar.hidden .sidebar-content {
      display: none;
    }
    .sidebar.hidden .sidebar-header {
      display: none;
    }
    .lemma-item {
      padding: 0.5rem;
      margin-bottom: 0.25rem;
      background: white;
      border-radius: 4px;
      border-left: 3px solid transparent;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .lemma-item:hover {
      background: #e9ecef;
    }
    .lemma-item.heat-1 { border-left-color: rgba(255, 255, 0, 0.6); }
    .lemma-item.heat-2 { border-left-color: rgba(255, 200, 0, 0.7); }
    .lemma-item.heat-3 { border-left-color: rgba(255, 165, 0, 0.8); }
    .lemma-item.heat-4 { border-left-color: rgba(255, 100, 0, 0.9); }
    .lemma-item.heat-5 { border-left-color: rgba(255, 50, 0, 1); }
    .lemma-text {
      flex: 1;
      font-weight: 500;
      color: #212529;
    }
    .lemma-frequency {
      font-size: 0.9rem;
      color: #6c757d;
      margin-left: 0.5rem;
      font-weight: 600;
    }
    .lemma-item.focused {
      background: #e3f2fd;
      border-left-width: 4px;
      font-weight: 600;
    }
    .lemma-item.dimmed {
      opacity: 0.4;
    }
    .clear-focus-button {
      width: 100%;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: background-color 0.2s;
    }
    .clear-focus-button:hover {
      background: #0056b3;
    }
    .sidebar-toggle-button {
      position: fixed;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px 0 0 4px;
      padding: 0.75rem 0.5rem;
      cursor: pointer;
      z-index: 1000;
      font-size: 1.2rem;
      transition: background-color 0.2s;
    }
    .sidebar-toggle-button:hover {
      background: #0056b3;
    }
    .sidebar-toggle-button.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <h1>Éditeur Markdown avec lemmatisation et mise en évidence des répétitions</h1>

  <div class="controls">
    <button id="analyzeBtn" class="analysis-button">Analyser le texte</button>
    <div class="progress-container">
      <div class="progress-bar">
        <div id="progressFill" class="progress-fill"></div>
      </div>
      <div id="statusText" class="status-text">Prêt</div>
      <div id="errorMessage" class="error-message"></div>
    </div>
    <div id="stats" class="stats">Mots: 0 | Répétitions: 0</div>
    <button id="sidebarToggleBtn" class="analysis-button" style="margin-left: auto;">Afficher les répétitions</button>
  </div>

  <div class="main-container">
    <div class="editor-wrapper">
      <div id="editor"></div>
    </div>
    
    <div id="sidebar" class="sidebar hidden">
      <div class="sidebar-header">
        <h2>Répétitions</h2>
        <button id="sidebarCloseBtn" class="sidebar-toggle" aria-label="Fermer">×</button>
      </div>
      <div id="sidebarContent" class="sidebar-content">
        <p style="padding: 1rem; color: #6c757d; text-align: center;">
          Analysez le texte pour voir les répétitions
        </p>
      </div>
    </div>
  </div>
  <!-- Zone où les messages de débogage seront affichés lorsqu’elle est présente. -->
  <!--
    Le script principal est chargé en tant que module afin de pouvoir
    utiliser l’instruction import.  Il instancie l’éditeur CodeMirror,
    configure le travailleur Web et gère la mise à jour des décorations.
  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/markdown/markdown.min.js"></script>
  <!--
    main.js n’est pas chargé comme module ES.  Il est exécuté dans
    l’espace global et peut accéder à window.CodeMirror.  Ce script
    instancie l’éditeur et le travailleur Web.
  -->
  <script src="./main.js"></script>

  <!--
    Le code du Web Worker est intégré directement dans la page dans
    un élément <script id="worker-code" type="javascript/worker">.  Le
    script principal récupère son contenu et crée un Worker à partir
    d’un Blob.  Cette technique évite les problèmes de chargement
    depuis le schéma file:// et permet de développer et tester
    l’éditeur hors ligne.
  -->
  <script id="worker-code" type="javascript/worker">
/*
 * Web Worker chargé de la lemmatisation française.  Ce script est
 * exécuté dans un contexte distinct du thread principal afin de ne
 * pas bloquer l'interface utilisateur lors du chargement des
 * dictionnaires et de l'analyse du texte.  Il charge le dictionnaire
 * bundlé (généré à build time) depuis dict-bundle.json, construit une
 * table de correspondance mot → lemme, puis pour chaque texte reçu
 * calcule les occurrences de chaque lemme et renvoie les plages à
 * surligner.
 */

// Chemin vers le fichier de dictionnaire bundlé (généré à build time)
const DICT_BUNDLE_URL = './dict-bundle.json';

// Configuration IndexedDB
const DB_NAME = 'lemmatizer-dicts';
const DB_VERSION = 1;
const STORE_NAME = 'dictionaries';

// Promesse qui se résout lorsque les dictionnaires sont chargés et
// convertis en table de correspondance mot_nosc → lemme.  Le
// chargement est déclenché lors de la première requête reçue.
let dictPromise = null;

// Configuration de la heatmap
// HEATMAP_LEVELS: nombre de niveaux d'intensité (de 1 à HEATMAP_LEVELS)
// HEATMAP_TOP_WORDS: nombre de mots les plus fréquents à surligner (distribués sur les niveaux)
// HEATMAP_BASE_THRESHOLD: seuil de base (en occurrences par bloc de 200 mots) - minimum pour être considéré
const HEATMAP_LEVELS = 5;
const HEATMAP_TOP_WORDS = 20; // Top 20 mots les plus fréquents
// Seuil de base plus permissif pour afficher davantage de répétitions.
// Exemple: 1 occurrence par bloc de 200 mots ≃ seuil 1–2 selon la longueur.
const HEATMAP_BASE_THRESHOLD = 1; // occurrences par bloc de 200 mots

// Liste basique de mots fonctionnels (stop words) à ignorer pour
// l'analyse de fréquence.  Les mots présents dans cette liste ne
// déclencheront pas de surbrillance, même s'ils apparaissent
// fréquemment.  Les entrées doivent être normalisées (minuscules,
// sans diacritiques).
const STOP_LEMMAS = new Set([
  'le', 'la', 'les', 'un', 'une', 'des', 'du', 'de', 'a', 'à', 'au', 'aux',
  'et', 'en', 'que', 'qui', 'quoi', 'dont', 'où', 'ne', 'pas', 'ni', 'mais',
  'ou', 'si', 'sur', 'dans', 'ce', 'cette', 'ces', 'son', 'sa', 'ses',
  'mon', 'ma', 'mes', 'ton', 'ta', 'tes', 'notre', 'nos', 'votre', 'vos',
  'leur', 'leurs', 'on', 'il', 'ils', 'elle', 'elles', 'je', 'tu', 'vous',
  'nous', 'y', 'en', 'd', 'l', 'c', 's', 't', 'm', 'n', 'qu', 'jusqu', 
  'pour'
]);

/**
 * Liste personnalisée de mots à ignorer pour l'analyse.
 * Ajoutez ici les mots que vous souhaitez exclure de l'analyse de répétition.
 * Les mots doivent être en minuscules et sans accents (utiliser normalize() si nécessaire).
 */
const CUSTOM_IGNORE_LIST = [
  // Ajoutez vos mots à ignorer ici
];

// Combiner les listes de mots à ignorer
const IGNORED_LEMMAS = new Set([...STOP_LEMMAS, ...CUSTOM_IGNORE_LIST]);

/**
 * Normalise une chaîne : mise en minuscules et suppression des
 * diacritiques (accents).
 */
function normalize(str) {
  return str
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '');
}

/**
 * Envoie un message de progression au thread principal.
 */
function sendProgress(progress, message) {
  self.postMessage({ type: 'progress', progress, message });
}

/**
 * Ouvre la base de données IndexedDB.
 */
function openDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME);
      }
    };
  });
}

/**
 * Charge les dictionnaires depuis IndexedDB.
 */
async function loadFromIndexedDB() {
  try {
    const db = await openDatabase();
    const transaction = db.transaction([STORE_NAME], 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.get('dictionary-map');
    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        const data = request.result;
        if (data && data.entries) {
          const map = new Map(data.entries);
          resolve(map);
        } else {
          resolve(null);
        }
      };
      request.onerror = () => reject(request.error);
    });
  } catch (err) {
    console.warn('Erreur lors du chargement depuis IndexedDB:', err);
    return null;
  }
}

/**
 * Sauvegarde les dictionnaires dans IndexedDB.
 */
async function saveToIndexedDB(map) {
  try {
    const db = await openDatabase();
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const data = { entries: Array.from(map.entries()), timestamp: Date.now() };
    await new Promise((resolve, reject) => {
      const request = store.put(data, 'dictionary-map');
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  } catch (err) {
    console.warn('Erreur lors de la sauvegarde dans IndexedDB:', err);
  }
}

/**
 * Charge le dictionnaire bundlé depuis le fichier JSON généré à build time.
 */
async function loadDictionaries() {
  sendProgress(10, 'Vérification du cache...');
  const cached = await loadFromIndexedDB();
  if (cached) {
    sendProgress(100, 'Dictionnaires chargés depuis le cache');
    return cached;
  }
  sendProgress(30, 'Chargement du dictionnaire bundlé...');
  try {
    const response = await fetch(DICT_BUNDLE_URL);
    if (!response.ok) {
      throw new Error(`Impossible de charger ${DICT_BUNDLE_URL}: HTTP ${response.status}`);
    }
    sendProgress(50, 'Parsing du dictionnaire...');
    const bundle = await response.json();
    if (!bundle.entries || !Array.isArray(bundle.entries)) {
      throw new Error('Format de bundle invalide');
    }
    sendProgress(70, 'Construction de la table de correspondance...');
    const map = new Map(bundle.entries);
    sendProgress(90, 'Sauvegarde dans le cache...');
    await saveToIndexedDB(map);
    sendProgress(100, 'Dictionnaires chargés');
    return map;
  } catch (err) {
    console.error('Erreur lors du chargement du dictionnaire:', err);
    throw err;
  }
}

function selectTopLemmas(counts, baseThreshold, topN) {
  const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);
  const eligible = entries.filter(([, freq]) => freq >= baseThreshold);
  if (eligible.length >= topN) return eligible.slice(0, topN);
  return entries.slice(0, Math.min(topN, entries.length));
}

/**
 * Calcule les niveaux de chaleur pour les lemmes basés sur leur rang de fréquence.
 */
function calculateHeatLevelsByRank(counts, baseThreshold) {
  const heatMap = new Map();
  const topLemmas = selectTopLemmas(counts, baseThreshold, HEATMAP_TOP_WORDS);
  if (topLemmas.length === 0) return heatMap;
  for (let i = 0; i < topLemmas.length; i++) {
    const [lemma] = topLemmas[i];
    const rankRatio = i / topLemmas.length;
    let heatLevel;
    if (rankRatio < 0.2) heatLevel = 5;
    else if (rankRatio < 0.4) heatLevel = 4;
    else if (rankRatio < 0.6) heatLevel = 3;
    else if (rankRatio < 0.8) heatLevel = 2;
    else heatLevel = 1;
    heatMap.set(lemma, heatLevel);
  }
  return heatMap;
}

/**
 * Analyse le texte et calcule les répétitions.
 */
function analyze(text, dict) {
  // Regex Unicode: lettres + apostrophes courantes + traits d’union
  const wordRegex = /[\p{L}'’ʼ\-\u2011]+/gu;
  const tokens = [];
  let scanned = 0;
  let ignored = 0;
  let total = 0;
  for (const match of text.matchAll(wordRegex)) {
    scanned++;
    let start = match.index;
    let rawWord = match[0];
    const segments = rawWord.split(/['’ʼ]/);
    const base = segments.length > 1 ? segments[segments.length - 1] : rawWord;
    const norm = normalize(base);
    if (norm.length === 0) { ignored++; continue; }
    if (IGNORED_LEMMAS.has(norm)) { ignored++; continue; }
    const lemma = dict.get(norm) || norm;
    if (IGNORED_LEMMAS.has(lemma)) { ignored++; continue; }
    tokens.push({ start, end: start + rawWord.length, lemma });
    total++;
  }
  const counts = Object.create(null);
  for (const tok of tokens) {
    counts[tok.lemma] = (counts[tok.lemma] || 0) + 1;
  }
  // Seuil basé sur la masse de répétition, min 2
  const repetitionMass = Object.values(counts).reduce((acc, c) => acc + (c > 1 ? (c - 1) : 0), 0);
  const baseThreshold = repetitionMass > 0
    ? Math.max(2, Math.ceil((HEATMAP_BASE_THRESHOLD * repetitionMass) / 200))
    : Infinity;
  const heatLevelMap = calculateHeatLevelsByRank(counts, baseThreshold);
  const highlights = [];
  for (const tok of tokens) {
    const heat = heatLevelMap.get(tok.lemma) || 0;
    if (heat > 0) {
      highlights.push({ start: tok.start, end: tok.end, heat, lemma: tok.lemma });
    }
  }
  const selectedEntries = selectTopLemmas(counts, baseThreshold, HEATMAP_TOP_WORDS);
  const lemmaFrequencies = selectedEntries.map(([lemma, freq]) => ({
    lemma,
    frequency: freq,
    heat: heatLevelMap.get(lemma) || 0
  }));
  const distinctLemmaCount = Object.keys(counts).length;
  let repeatedLemmaCount = 0;
  let repeatedTokenCount = 0;
  let eligibleLemmaCount = 0;
  for (const c of Object.values(counts)) {
    if (c >= 2) { repeatedLemmaCount++; repeatedTokenCount += c; }
    if (c >= baseThreshold) eligibleLemmaCount++;
  }
  const stats = {
    scannedWords: scanned,
    ignoredWords: ignored,
    analyzedTokens: total,
    distinctLemmaCount,
    repeatedLemmaCount,
    repeatedTokenCount,
    eligibleLemmaCount,
    selectedLemmaCount: heatLevelMap.size,
    highlightedTokenCount: highlights.length,
    baseThreshold
  };
  return { highlights, lemmaFrequencies, stats };
}

// Gestionnaire de messages
self.onmessage = async (e) => {
  const { text } = e.data;
  const startTime = performance.now();
  try {
    if (!dictPromise) {
      dictPromise = loadDictionaries();
    }
    const dict = await dictPromise;
    sendProgress(75, 'Analyse du texte...');
    const result = analyze(text, dict);
    const duration = Math.round(performance.now() - startTime);
    self.postMessage({
      type: 'complete',
      highlights: result.highlights,
      lemmaFrequencies: result.lemmaFrequencies,
      stats: { duration, ...(result.stats || {}) }
    });
  } catch (err) {
    console.error('Erreur d\'analyse :', err);
    self.postMessage({
      type: 'error',
      error: err.message || 'Erreur inconnue',
      highlights: []
    });
  }
};
  </script>
</body>
</html>
